import path from 'node:path';
import { fileURLToPath } from 'node:url';
import fs from 'fs-extra';
import { convertAgentToSkill } from './src/converters/agent-converter.js';
import { convertWorkflowToSkill } from './src/converters/workflow-converter.js';
import { fetchBmadRepo } from './src/utils/bmad-fetcher.js';
import { findAgentsAndWorkflows } from './src/utils/file-finder.js';
import { migrateResources } from './src/utils/resource-migrator.js';
import { writeSkill } from './src/utils/skill-writer.js';

/**
 * Get module-specific config content matching BMAD installer format
 * @param {string} moduleName - Module name (core, bmm, bmb)
 * @returns {string} YAML config content
 */
function getModuleConfigContent(moduleName) {
  const header = `# ${moduleName.toUpperCase()} Module Configuration
# Generated by BMAD Skills Converter
# Date: ${new Date().toISOString()}
#
# Customize these values for your project.
# Run the bootstrap-bmad-skills skill for guided configuration.

`;

  switch (moduleName) {
    case 'core':
      return (
        header +
        `# Your name/handle for personalized interactions
user_name: ''

# Language for AI communication
communication_language: English

# Language for generated documents
document_output_language: English

# Base output folder for BMAD artifacts
output_folder: "{project-root}/documents/bmad"
`
      );

    case 'bmm':
      return (
        header +
        `# Your project name
project_name: ''

# Your development experience level (beginner, intermediate, expert)
# Affects how agents explain concepts
user_skill_level: intermediate

# Where to store planning artifacts (Briefs, PRDs, UX Designs, Architecture)
planning_artifacts: "{project-root}/documents/bmad/planning-artifacts"

# Where to store implementation artifacts (Sprint status, stories, reviews)
implementation_artifacts: "{project-root}/documents/bmad/implementation-artifacts"

# Where to store long-term project knowledge (docs, research)
project_knowledge: "{project-root}/docs"

# TEA (Test Engineering Architect) options
tea_use_mcp_enhancements: false
tea_use_playwright_utils: false

# Core Configuration Values (inherited)
user_name: ''
communication_language: English
document_output_language: English
output_folder: "{project-root}/documents/bmad"
`
      );

    case 'bmb':
      return (
        header +
        `# Where to save custom agents, workflows, and modules
bmb_creations_output_folder: "{project-root}/documents/bmad/bmb-creations"

# Core Configuration Values (inherited)
user_name: ''
communication_language: English
document_output_language: English
output_folder: "{project-root}/documents/bmad"
`
      );

    default:
      return (
        header +
        `# Add module-specific configuration below
`
      );
  }
}

/**
 * Generate config.yaml for each module in the output directory
 * Matches BMAD installer behavior - creates per-module configuration files
 * @param {string} outputDir - Output directory containing skills
 */
async function generateModuleConfigs(outputDir) {
  console.log('üìù Generating module configs...');

  const modules = await fs.readdir(outputDir);

  for (const moduleName of modules) {
    const modulePath = path.join(outputDir, moduleName);

    // Skip if not a directory
    if (!(await fs.stat(modulePath)).isDirectory()) {
      continue;
    }

    const configPath = path.join(modulePath, 'config.yaml');

    // Don't overwrite existing config
    if (await fs.pathExists(configPath)) {
      console.log(`  ‚è≠ ${moduleName}/config.yaml (exists)`);
      continue;
    }

    const configContent = getModuleConfigContent(moduleName);
    await fs.writeFile(configPath, configContent, 'utf8');
    console.log(`  ‚úì ${moduleName}/config.yaml`);
  }

  console.log();
}

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Parse command line arguments
 */
function parseArgs() {
  const args = process.argv.slice(2);
  const options = {
    outputDir: null,
    repoUrl: null,
    branch: null,
    identityCharLimit: null,
    addExamples: null,
    addBestPractices: null,
    addTroubleshooting: null,
    addRelatedSkills: null,
    generateMetaDocs: null,
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    if (arg === '--output-dir' && i + 1 < args.length) {
      options.outputDir = args[++i];
    } else if (arg === '--repo' && i + 1 < args.length) {
      options.repoUrl = args[++i];
    } else if (arg === '--branch' && i + 1 < args.length) {
      options.branch = args[++i];
    } else if (arg === '--identity-limit' && i + 1 < args.length) {
      const limit = Number.parseInt(args[++i], 10);
      options.identityCharLimit = Number.isNaN(limit) ? null : limit;
    } else if (arg === '--no-examples') {
      options.addExamples = false;
    } else if (arg === '--examples') {
      options.addExamples = true;
    } else if (arg === '--no-best-practices') {
      options.addBestPractices = false;
    } else if (arg === '--best-practices') {
      options.addBestPractices = true;
    } else if (arg === '--no-troubleshooting') {
      options.addTroubleshooting = false;
    } else if (arg === '--troubleshooting') {
      options.addTroubleshooting = true;
    } else if (arg === '--no-related-skills') {
      options.addRelatedSkills = false;
    } else if (arg === '--related-skills') {
      options.addRelatedSkills = true;
    } else if (arg === '--no-meta-docs') {
      options.generateMetaDocs = false;
    } else if (arg === '--meta-docs') {
      options.generateMetaDocs = true;
    } else if (arg === '--help' || arg === '-h') {
      printHelp();
      process.exit(0);
    }
  }

  return options;
}

/**
 * Print help message
 */
function printHelp() {
  console.log(`
BMAD to Skills Converter

Usage: pnpm convert [options]

Options:
  --output-dir <path>        Custom output directory (default: ./skills)
                            Use a non-version-controlled folder for custom configs
  
  --repo <url>              Override BMAD repository URL
  --branch <name>           Override BMAD branch (default: main)
  
  --identity-limit <num>    Character limit for identity in description
                            (default: no limit, use --identity-limit 200 to enable old behavior)
  
  Optional Enhancements (override config.json defaults):
    --examples / --no-examples
    --best-practices / --no-best-practices
    --troubleshooting / --no-troubleshooting
    --related-skills / --no-related-skills
    --meta-docs / --no-meta-docs
  
  -h, --help                Show this help message

Examples:
  # Use default config (outputs to ./skills, version controlled)
  pnpm convert
  
  # Output to custom directory with different settings
  pnpm convert --output-dir ./custom-skills --identity-limit 200 --no-examples
  
  # Enable troubleshooting for this run
  pnpm convert --troubleshooting
`);
}

// Parse CLI arguments
const cliOptions = parseArgs();

// Load configuration
const configPath = path.join(__dirname, 'config.json');
let config;
try {
  if (!(await fs.pathExists(configPath))) {
    throw new Error(`Configuration file not found: ${configPath}`);
  }
  const configContent = await fs.readFile(configPath, 'utf-8');
  config = JSON.parse(configContent);

  // Validate required config fields
  const requiredFields = ['bmadRepo', 'bmadBranch', 'outputDir', 'tempDir'];
  for (const field of requiredFields) {
    if (!config[field]) {
      throw new Error(`Missing required configuration field: ${field}`);
    }
  }

  // Merge CLI options with config
  if (cliOptions.outputDir) {
    config.outputDir = cliOptions.outputDir;
  }
  if (cliOptions.repoUrl) {
    config.bmadRepo = cliOptions.repoUrl;
    console.log(`‚ÑπÔ∏è  Overriding BMAD Repo: ${config.bmadRepo}`);
  }
  if (cliOptions.branch) {
    config.bmadBranch = cliOptions.branch;
    console.log(`‚ÑπÔ∏è  Overriding BMAD Branch: ${config.bmadBranch}`);
  }

  // Initialize enhancements config if not present
  if (!config.enhancements) {
    config.enhancements = {};
  }
  if (!config.enhancements.optional) {
    config.enhancements.optional = {
      addExamples: true,
      addBestPractices: true,
      addTroubleshooting: false,
      addRelatedSkills: true,
      generateMetaDocs: false,
    };
  }

  // Override with CLI options
  if (cliOptions.identityCharLimit !== null) {
    config.enhancements.identityCharLimit = cliOptions.identityCharLimit;
  }
  if (cliOptions.addExamples !== null) {
    config.enhancements.optional.addExamples = cliOptions.addExamples;
  }
  if (cliOptions.addBestPractices !== null) {
    config.enhancements.optional.addBestPractices = cliOptions.addBestPractices;
  }
  if (cliOptions.addTroubleshooting !== null) {
    config.enhancements.optional.addTroubleshooting =
      cliOptions.addTroubleshooting;
  }
  if (cliOptions.addRelatedSkills !== null) {
    config.enhancements.optional.addRelatedSkills = cliOptions.addRelatedSkills;
  }
  if (cliOptions.generateMetaDocs !== null) {
    config.enhancements.optional.generateMetaDocs = cliOptions.generateMetaDocs;
  }
} catch (error) {
  console.error(`‚ùå Failed to load configuration: ${error.message}`);
  process.exit(1);
}

// Statistics
const stats = {
  agents: { total: 0, converted: 0, errors: 0 },
  workflows: { total: 0, converted: 0, errors: 0 },
  errors: [],
};

/**
 * Main conversion function
 */
async function main() {
  console.log('üöÄ BMAD to Skills Converter\n');

  try {
    // Step 1: Fetch BMAD repository
    console.log('üì• Fetching BMAD-METHOD repository...');
    const bmadRoot = await fetchBmadRepo(
      config.bmadRepo,
      config.bmadBranch,
      path.resolve(process.cwd(), config.tempDir)
    );
    console.log(`‚úì Repository ready at: ${bmadRoot}\n`);

    // Step 2: Discover agents and workflows
    console.log('üîç Discovering agents and workflows...');
    const { agents, workflows } = await findAgentsAndWorkflows(
      bmadRoot,
      config.agentPaths,
      config.workflowPaths
    );

    stats.agents.total = agents.length;
    stats.workflows.total = workflows.length;

    console.log(
      `‚úì Found ${agents.length} agents and ${workflows.length} workflows\n`
    );

    // Step 3: Prepare output directory
    const outputDir = path.resolve(process.cwd(), config.outputDir);
    await fs.ensureDir(outputDir);
    console.log(`üìÅ Output directory: ${outputDir}\n`);

    // Step 3.5: Build skillMap for path rewriting
    // Maps source file paths (relative to bmadRoot) to destination skill paths
    const skillMap = new Map();

    for (const agent of agents) {
      let relPath = path.relative(bmadRoot, agent.path);
      // Normalize path to match BMAD content conventions (strip src/modules/)
      if (relPath.startsWith('src/modules/')) {
        relPath = relPath.replace('src/modules/', '');
      }
      skillMap.set(relPath, { module: agent.module, name: agent.name });
    }

    for (const workflow of workflows) {
      let relPath = path.relative(bmadRoot, workflow.path);
      // Normalize path to match BMAD content conventions (strip src/modules/)
      if (relPath.startsWith('src/modules/')) {
        relPath = relPath.replace('src/modules/', '');
      }
      skillMap.set(relPath, { module: workflow.module, name: workflow.name });
    }

    // Step 4: Convert agents
    if (agents.length > 0) {
      console.log('ü§ñ Converting agents...');
      const agentOptions = {
        identityCharLimit: config.enhancements.identityCharLimit ?? null,
        allAgents: agents,
        allWorkflows: workflows,
      };
      for (const agent of agents) {
        try {
          const skillContent = await convertAgentToSkill(agent.path, {
            ...agentOptions,
            currentModule: agent.module,
          });
          await writeSkill(outputDir, agent.module, agent.name, skillContent, {
            skillMap,
          });
          stats.agents.converted++;
          console.log(`  ‚úì ${agent.module}/${agent.name}`);
        } catch (error) {
          stats.agents.errors++;
          stats.errors.push({
            type: 'agent',
            path: agent.path,
            error: error.message,
          });
          console.error(`  ‚úó ${agent.module}/${agent.name}: ${error.message}`);
        }
      }
      console.log();
    }

    // Step 5: Convert workflows
    if (workflows.length > 0) {
      console.log('‚öôÔ∏è  Converting workflows...');
      const workflowOptions = {};
      for (const workflow of workflows) {
        try {
          const skillContent = await convertWorkflowToSkill(
            workflow.path,
            workflow.instructionsPath,
            workflow.workflowDir,
            workflow.instructionsType,
            {
              ...workflowOptions,
              isMarkdown: workflow.isMarkdown || false,
              bmadRoot,
              bmadRepo: config.bmadRepo,
              bmadBranch: config.bmadBranch,
            }
          );
          await writeSkill(
            outputDir,
            workflow.module,
            workflow.name,
            skillContent,
            {
              workflowDir: workflow.workflowDir,
              skillMap,
            }
          );
          stats.workflows.converted++;
          console.log(`  ‚úì ${workflow.module}/${workflow.name}`);
        } catch (error) {
          stats.workflows.errors++;
          stats.errors.push({
            type: 'workflow',
            path: workflow.path,
            error: error.message,
          });
          console.error(
            `  ‚úó ${workflow.module}/${workflow.name}: ${error.message}`
          );
        }
      }
      console.log();
    }

    // Step 6: Migrate auxiliary resources
    await migrateResources(bmadRoot, outputDir);

    // Step 7: Generate module configs (same as BMAD installer)
    await generateModuleConfigs(outputDir);

    // Step 8: Generate summary
    await printSummary();
  } catch (error) {
    console.error(`\n‚ùå Fatal error: ${error.message}`);
    console.error(error.stack);
    process.exit(1);
  }
}

/**
 * Prints conversion summary
 */
async function printSummary() {
  console.log('üìä Conversion Summary\n');
  console.log('Agents:');
  console.log(`  Total: ${stats.agents.total}`);
  console.log(`  Converted: ${stats.agents.converted}`);
  console.log(`  Errors: ${stats.agents.errors}`);
  console.log();
  console.log('Workflows:');
  console.log(`  Total: ${stats.workflows.total}`);
  console.log(`  Converted: ${stats.workflows.converted}`);
  console.log(`  Errors: ${stats.workflows.errors}`);
  console.log();

  const totalConverted = stats.agents.converted + stats.workflows.converted;
  const totalErrors = stats.agents.errors + stats.workflows.errors;

  if (totalErrors > 0) {
    console.log('‚ö†Ô∏è  Errors encountered:');
    for (const err of stats.errors) {
      console.log(`  - ${err.type}: ${err.path}`);
      console.log(`    ${err.error}`);
    }
    console.log();
  }

  console.log(`‚úÖ Successfully converted ${totalConverted} skills`);
  console.log(
    `üìÅ Output directory: ${path.resolve(process.cwd(), config.outputDir)}`
  );

  // Show configuration info
  if (config.outputDir !== './skills') {
    console.log('\nüí° Note: Output directory is not the default (./skills)');
    console.log('   This directory is not version controlled.');
    console.log('   To use default settings, run without --output-dir flag.');
  }

  if (config.enhancements.identityCharLimit !== null) {
    console.log(
      `\nüí° Note: Identity character limit is set to ${config.enhancements.identityCharLimit}`
    );
    console.log(
      '   Default behavior (no limit) is recommended for better content.'
    );
  }

  // Print per-module breakdown
  if (totalConverted > 0) {
    console.log('\nüì¶ Per-module breakdown:');

    // Count by module from output structure
    const outputDir = path.resolve(process.cwd(), config.outputDir);
    if (await fs.pathExists(outputDir)) {
      const modules = await fs.readdir(outputDir);
      for (const module of modules) {
        const modulePath = path.join(outputDir, module);
        if ((await fs.stat(modulePath)).isDirectory()) {
          const items = await fs.readdir(modulePath);
          // Only count directories (skills), not files like config.yaml
          let skillCount = 0;
          for (const item of items) {
            const itemPath = path.join(modulePath, item);
            if ((await fs.stat(itemPath)).isDirectory()) {
              skillCount++;
            }
          }
          console.log(`  ${module}: ${skillCount} skills`);
        }
      }
    }
  }
}

// Run the conversion
main().catch((error) => {
  console.error('Unhandled error:', error);
  process.exit(1);
});
